#include "Imagem.h"
#include <iostream>
#include <fstream>
#include <filesystem>
/**
 *  ...
 */


/**
 * @brief 
 * Função responsável por tornar o atributo do pixel par.
 *
 * @param valor componente do pixel a ser alterado.
 */
void tornar_par(int &valor)
{
    if (valor % 2 != 0)
    {
        valor--;
    }
}
/**
 * @brief 
 * Função responsável por tornar o atributo do pixel ímpar.
 * 
 * @param valor componente do pixel a ser alterado.
 */
void tornar_impar(int &valor)
{
    if (valor % 2 == 0)
    {
        valor++;
    }
}
/**
 * @brief
 * Função que realiza a operação de potenciação entre dois valores.
 * 
 * @param base base da potência
 * @param expoente expoente da potência
 * @return operação de potência da base pelo expoente
 */
int potencia(int base, int expoente)
{
    if (expoente == 0)
    {
        return 1;
    }
    else
    {
        int resultado = 1;
        for (int i = 0; i < expoente; ++i)
        {
            resultado *= base;
        }
        return resultado;
    }
}
/**
 * @brief
 * Função que retorna a altura da objeto.
 * 
 * @return altura do objeto
 */

int Imagem::get_altura()
{
    return Imagem::altura;
}
/**
 * @brief
 * Função que altera a altura do objeto.
 * 
 * @param altura altura do objeto
 */
void Imagem::set_altura(int altura)
{
    this->altura = altura;
}
/**
 * @brief
 * Função que retorna a largura do objeto.
 * 
 * @return largura do objeto
 */

int Imagem::get_largura()
{
    return Imagem::largura;
}
/**
 * @brief
 * Função responsável por alterar a largura da imagem.
 * 
 * @param largura
 */
void Imagem::set_largura(int largura)
{
    this->largura = largura;
}
/**
 * @brief
 * Função que aloca a memória dinamicamente para uma matriz de pixels.
 */
void Imagem::alocar_memoria()
{
    pixels = new Pixel *[altura];

    for (int i = 0; i < altura; ++i)
    {
        pixels[i] = new Pixel[largura];
    }
}
/**
 * @brief
 * Função que cria o objeto do tipo Imagem.
 * 
 * @param arquivo_entrada arquivo a ser lido pela função.
 */
void Imagem::criar_imagem(string arquivo_entrada)
{

    ifstream arquivo(arquivo_entrada);
    if (arquivo.is_open())
    {
        string linha;
        getline(arquivo, linha);
        if (linha != "P3")
        {
            cerr << "Tipo de arquivo PPM não suportado: " << linha << endl;
            return;
        }

        int largura, altura, valor_maximo_cor;

        arquivo >> largura >> altura >> valor_maximo_cor;
        set_largura(largura);
        set_altura(altura);
        alocar_memoria();

        for (int i = 0; i < altura; i++)
        {
            for (int j = 0; j < largura; j++)
            {
                int r, g, b;
                arquivo >> r >> g >> b;
                get_pixels()[i][j] = {r, g, b};
            }
        }
        arquivo.close();
    }
    else
    {
        cerr << "Erro ao abrir o arquivo: " << arquivo_entrada << endl;
    }
}
/**
 * @brief
 * Função responsável por codificar a mensagem dentro da imagem criada.
 *
 * @param mensagem Mensagem a ser codificada.
 * @return confirmação sobre a codificação da mensagem. 
 */
bool Imagem::codificar(std::string mensagem)
{
    if (mensagem.size() * 8 >= get_largura() * get_altura() * 3)
    {
        cout << "Mensagem maior que a capacidade da imagem." << endl;
        return false;
    }

    int *array = new int[mensagem.size() + 1];  //new int[mensagem.size() + 1] é um array alocado dinamicamente de inteiros (porque os caracteres vão virar char ja)
    array[0] = mensagem.size(); //priemrio valor do array é 0
    int i = 1; //para sinalizar que o for vai começar a aprtir do segundo valor do array

    for (auto c : mensagem)
    {
        array[i] = static_cast<int>(c); //percorre todos os caracteres da mensagem e os transforma em seu valor inteiro correspondente E armazena na array
        i++;
    }
    //ao final desse for, temos um array que armazenou todo a mensagem transformada ja em inteiros
    int count = 7;
    int k = 0;

    for (int j = 2; j < 3 + mensagem.size(); j++)
    {
        int value1 = array[k]; //esse k inicia no zero, mas ao final de cada rodada do for ele é incrementado (ou seja, vai codificar o proximo valor do array)

        for (int i = 0; i < 8; i++)
        {
            int pixel_x = (count / 3) / get_largura();  //refletir sobre essa aprte
            int pixel_y = (count / 3) % get_largura();
            auto &pixel = get_pixels()[pixel_x][pixel_y]; //codigo responsavel por acessar o pixel.

            if (count % 3 == 0)
            {
                value1 % 2 == 0 ? tornar_par(pixel.r) : tornar_impar(pixel.r);
            }
            else if (count % 3 == 1)
            {
                value1 % 2 == 0 ? tornar_par(pixel.g) : tornar_impar(pixel.g);
            }
            else if (count % 3 == 2)
            {
                value1 % 2 == 0 ? tornar_par(pixel.b) : tornar_impar(pixel.b);
            }
            //dependendo do resto de count por 3, ele vê qual atributo do pixel acessa
            value1 /= 2;
            count--;

            // if (count < 0)
            // {
            //     count = (8 * (j + 1)) - 1;       CODIGO REDUNDANTE POIS A LOGICA SEMELHANTE LA DEBAIXO É QUEM CONTROLA 
            // }                                        
        }

        if (array[k] == 0)      //se o tamanho da mensagem for zero, realiza esse for para transformar os 8 primeiros bits em 0 (e dizer que o tamanho é 0)
        {
            for (int prev_count = count + 1; prev_count <= (8 * j) - 1; prev_count++)
            {
                int prev_pixel_x = (prev_count / 3) / get_largura();
                int prev_pixel_y = (prev_count / 3) % get_largura();
                auto &prev_pixel = get_pixels()[prev_pixel_x][prev_pixel_y];

                if (prev_count % 3 == 0)
                {
                    tornar_par(prev_pixel.r);
                }
                else if (prev_count % 3 == 1)
                {
                    tornar_par(prev_pixel.g);
                }
                else if (prev_count % 3 == 2)
                {
                    tornar_par(prev_pixel.b);
                }
            }
        }

        k++;
        count = (8 * j) - 1;  //do 7 vai pra 15 -> 23 -> e assim por diante, pois vai codificar voltando
    }

    delete[] array; //libera a memoria que foi alocada pela array
    return true;
}
/**
 * @brief
 * Função responsável por salvar a imagem codificada em um arquivo de saída.
 * 
 * @param arquivo_saida Arquivo de destino da imagem codificada.
 */
void Imagem::salvar(string arquivo_saida)       //função de formatação do arquivo resultado, vai salvar a iamgem codificada no arquivo
{
    ofstream arquivo(arquivo_saida);
    if (arquivo.is_open())
    {
        arquivo << "P3" << endl;
        arquivo << get_largura() << " " << get_altura() << endl;
        arquivo << "255" << endl;

        for (int i = 0; i < get_altura(); i++)
        {
            for (int j = 0; j < get_largura(); j++)
            {
                arquivo << get_pixels()[i][j].r << " ";
                arquivo << get_pixels()[i][j].g << " ";
                arquivo << get_pixels()[i][j].b << "   ";  //vai enviar os atributos dos pixels de volta pro arquivo, agora ja codificados
            arquivo << endl;
        }
        arquivo.close();
    }
}
/**
 * @brief
 * Função que retorna a matriz de pixels da imagem.
 * 
 * @return matriz de pixels.
 */
Pixel **get_pixels();
{
    return pixels;
}
/**
 * @brief
 * Função responsável por decodificar a mensagem codificada em uma imagem.
 * 
 * @param arquivo_entrada Arquivo que contém a mensagem à ser decodificada.
 */
void decodificar(string arquivo_entrada);
{
    int tamanho = 0, acumulad = 0;

    for (int i = 7; i >= 0; i--)
    {
        int pixel_y = (i / 3) % get_largura();
        auto &pixel = get_pixels()[0][pixel_y]; //codigo para definir o pixel acessado

        if (i % 3 == 0)
        {
            tamanho += (pixel.r % 2) * potencia(2, acumulad);
        }
        else if (i % 3 == 1)
        {
            tamanho += (pixel.g % 2) * potencia(2, acumulad);
        }
        else if (i % 3 == 2)
        {
            tamanho += (pixel.b % 2) * potencia(2, acumulad);
        }

        acumulad++;         //cada else if desse vai definir o atributo do pixel a ser acessado e o resultado será o tamanho da mensagem a ser decodificada
    }

    if (tamanho * 8 >= get_largura() * get_altura() * 3)
    {
        cout << "Tamanho da mensagem maior que a capacidade da imagem." << endl;
        return;                                                                     //execeção em relação ao tamanho, meio redundante porque so chegaria aqui com uma modificação manual
    }

    int count = 15; //ja inicia no proximo set de pixels (8 bits à frente)
    for (int j = 3; j < tamanho + 3; j++)
    {

        int soma = 0, acumulado = 0;

        for (int i = 0; i < 8; i++)
        {
            int pixel_x = (count / 3) / get_largura();
            int pixel_y = (count / 3) % get_largura();
            auto &pixel = get_pixels()[pixel_x][pixel_y]; //acessa o pixel

            if (count % 3 == 0)
            {
                soma += (pixel.r % 2) * potencia(2, acumulado);
            }
            else if (count % 3 == 1)
            {
                soma += (pixel.g % 2) * potencia(2, acumulado);
            }
            else if (count % 3 == 2)
            {
                soma += (pixel.b % 2) * potencia(2, acumulado);
            }
            if (i + 1 == 8)
            {
                cout << (char)soma; //envia pra saida direto a letra decodificada
            }
            acumulado++;
            count--;
        }
        count = (8 * j) - 1; //acessa o proximo valor de count ja acima de 15 (23, 31, etc)
    }
    cout << endl;
}
